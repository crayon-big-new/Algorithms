# 3-插入排序

## 算法思想

把第一个元素当成一个数组，从第二个元素开始，插入数组中的正确位置，即和前面所有元素依次比较，如果比前面元素小，就交换。一直到最后一个元素插入完成，排序完成。

所以第N次循环时，前N个元素是有序排列的。



## 算法实现

```java
    public static void sort(Comparable[] a) {
        int N = a.length;
        //i从1开始，不需要排第一个元素，一直到最后一个
        for(int i = 1; i < N; i++) {
            //j不能为0，即第一个元素
            for(int j = i; j > 0; j--) {
                //如果a[j] < a[j + 1]，交换元素
                if(less(a[j], a[j - 1])) {
                    exch(a, j, j - 1);
                    //如果a[j]大于a[j - 1]，自然大于a[j - 1]前所有元素，所以结束这次循环
                } else {
                    break;
                }
            }
        }
    
    }
```



上述代码中的内循环，可改成`for(int j = i; j > 0 && less(a[j], a[j - 1]); j--) { exch(a, j, j - 1); }`

代码会更简洁。



## 算法性能分析

插入排序所需时间取决于元素的初始顺序。如果元素初始为有序或者元素全相等的，那么不需要交换，比较次数为N - 1。

如果元素为逆序，那么需要比较 次数为 1 + 2 + ... + (N -1) = $\frac{N(N-1)}{2}$，同样，每比较一次，就要交换一次，所以交换次数也是$\frac{N(N-1)}{2}$~${N^2}/2$次。



总上，对于一个有N个元素并且主键不重复的数组：

平均情况下：比较次数为~ ${N^2}/4$次，交换次数也为~${N^2}/4$次

最坏情况下：比较次数为~ ${N^2}/2$次，交换次数也为~${N^2}/2$次

最好情况下：比较次数为 N - 1 次，交换次数为0



## 特点

插入排序更适合部分有序的数组。

说一个概念：倒置。

倒置指的是数组中顺序颠倒的两个元素。例如 2， 3， 5， 1。有3对倒置：2和1， 3和1， 5和1。

最多有$\frac{N(N-1)}{2}$对倒置。

几种常见的部分有序数组：

- 数组中每个元素距离它的最终位置都不远
- 一个有序的大数组接一个小数组
- 数组中只有几个元素的位置不正确

命题：插入排序需要的交换次数和数组中倒置数量相同。需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组大小减1。

证明：有多少对倒置元素，就需要交换多少次。 

​			每次交换对应一个比较，并且从第一个元素到第N - 1个元素，都可能需要额外的一次比较。



总的来说，插入排序非常适合部分有效的数组，也适合小规模数组。