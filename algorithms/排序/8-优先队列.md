# 8-优先队列



有时候不一定要求全部数组有序，或者不一定要求一次就将它排序。很多时候，我们会收集一些元素，处理当前键值最大的元素，然后再收集更多元素，再处理键值最大元素。

​		这种情况下，一个合适的数据结构应该支持两种操作：删除最大元素和插入元素。这种数据结构叫做优先队列。

优先队列的使用和队列(删除最老的元素)以及栈(删除最新的元素)类似。



## API

优先队列是一种抽象数据类型，它表示了一组值和对这些值的操作。

`public class MaxPQ(Key extends Comparable<Key>)`

| 方法定义           | 方法含义                    |
| ------------------ | --------------------------- |
| MaxPQ()            | 创建一个优先队列            |
| MaxPQ(int max)     | 创建一个容量为max的优先队列 |
| MaxPQ(Key[] a)     | 用a[]中元素创建一个优先队列 |
| void insert(Key v) | 向优先队列中插入一个元素    |
| Key max()          | 返回最大元素                |
| Key delMax()       | 删除最大元素                |
| boolean isEmpty()  | 返回队列是否为空            |
| int size()         | 返回优先队列中的元素个数    |

可以很方便的修改MaxPQ类变成MinPQ类。



## 优先队列的调用实例

为了展示优先队列的抽象模型价值，考虑一个问题：输入N个字符串，每个字符串对应一个整数，从中找出最大的(或者最小的)M个整数。在某些应用场景，输入量可能非常巨大，甚至认为输入是无限的，解决这个问题的一种方法是将输入排序，然后找出最大的M个元素。但已经说明了输入非常巨大。另一种方式是将每个新的输入和已知的M个最大元素比较，但是除非M较小，否则比较的代价也会很高。只要能高效的实现Insert()和delMin()。



| 示例                     | 时间    | 空间 |
| ------------------------ | ------- | ---- |
| 排序算法的用例           | $NlogN$ | N    |
| 调用初级实现的优先队列   | $NM$    | M    |
| 调用基于堆排序的优先队列 | $NlogM$ | M    |





## 初级实现



### 数组实现

​			上述部分API的数组实现

```java
    public void show() {
        for(int i = 0; i < size; i++) {
            System.out.print((Key) a[i] + " ");
        }
    }

    public boolean isEmpty() {
        return size == 0;
    }
    public int size() {
        return this.size;
    }

    private boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }
    private void exch(Comparable[] a, int i ,int j) {
        Comparable temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
```



#### 无序数组



要实现删除最大元素代码，只需要使用类似选择排序的内循环来找出最大值，将最大元素和边界元素交换然后删除它。

所谓 无序数组，就是数组内部是没有排好序的，只在返回最大值或者删除最大值时使用了类似选择排序找出最大值。



##### 代码实现：

```java
import java.util.Arrays;

//使用数组实现优先队列
//无序
public class MaxPQ<Key extends Comparable<Key>> {
    //如果不指定数组长度，默认是10
    private int defalutLength = 10;
    private Comparable[] a;

    // 数组的元素个数
    private Integer size = 0;
    // 数组的容量
    private Integer length;
    public MaxPQ() {
        a = new Comparable[defalutLength];
        length = defalutLength;
    }
    public MaxPQ(int max) {
        a = new Comparable[max];
        length = max;
    }
    public MaxPQ(Key[] a) {
        length = a.length;
        //将数组复制过去
        this.a = new Comparable[length];
        for(int i = 0; i < length; i++) {
            this.insert(a[i]);
        }
    }

    public void insert(Key v) {
        if(size.equals(length)) {
            //如果数组满了，就创建一个是原来长度2倍的数组，把元素复制过去
            a = Arrays.copyOf(a, 2 * length);
            length = 2 * length;
        }
        a[size++] = v;

    }

    public Key max() {
        if(size == 0) {return null;}
        else if(size == 1) {return (Key) a[0];}

        int max = size - 1;
        for(int i = 0; i < size - 1; i++) {
            if(less(a[max], a[i])) {
                max = i;
            }
        }
        if(max != size - 1) {
            exch(a, max, size - 1);
        }
        return (Key) a[size - 1];
    }

    public Key delMax() {
        Key v = max();
        size--;
        return v;
    }


}

```



#### 有序数组

另外一种方法就是在insert方法中，使用插入排序，就是每插入一个元素，就和前面所有元素比较，插入到相应位置。

这样整个数组总是有序的，而且最大元素在数组一边。



##### 代码实现

```java
package example;

import java.util.Arrays;

//使用数组实现优先队列
//有序
public class MaxPQ<Key extends Comparable<Key>> {
    //如果不指定数组长度，默认是10
    private int defalutLength = 10;

    private Comparable[] a;

    // 数组的元素个数
    private Integer size = 0;

    // 数组的容量
    private Integer length;
    public MaxPQ() {
        a = new Comparable[defalutLength];
        length = defalutLength;
    }
    public MaxPQ(int max) {
        a = new Comparable[max];
        length = max;
    }
    public MaxPQ(Key[] a) {
        length = a.length;
        this.a = new Comparable[length];
        for(int i = 0; i < length; i++) {
            this.insert(a[i]);
        }
    }

    public void insert(Key v) {
        if(size.equals(length)) {
            //如果数组满了，就创建一个是原来长度2倍的数组，把元素复制过去
            a = Arrays.copyOf(a, 2 * length);
            length = 2 * length;
        }
        a[size++] = v;

        for(int i = size - 1; i > 0; i--) {
            if(less(a[i], a[i - 1])) {
                exch(a, i, i - 1);
            }
        }


    }

    public Key max() {
        if(size == 0) {
            return null;
        } else {
            return (Key) a[size - 1];
        }

    }

    public Key delMax() {
        Key v = max();
        size--;
        return v;
    }

}

```





### 链表实现

​		使用链表来实现优先队列。使用无序序列是解决这个问题的惰性方法，因为我们仅在必要的时候才会找出最大元素；使用有序序列是解决问题的积极方法，因为会在插入元素时就会保持列表有序。

​		同样，使用链表也有两种方法，一种是链表无序；一种是保持链表始终有序。

有序和无序其实实现方法类似，只不过一个在插入时遍历；另一个在删除时遍历。

所以这里只实现链表无序。

#### 代码实现

```java
import java.util.Arrays;

//使用无序链表实现优先队列
public class MaxPQ<Key extends Comparable<Key>> {

    private class Node {
        Key val;
        Node next;
        public Node(Key val) {
            this.val = val;
        }
    }

    private Node first;

    // 数组的元素个数(链表实现其实可以去掉)
    private Integer size = 0;

    public MaxPQ() {}

    public MaxPQ(Key[] a) {
        size = a.length;
        for(Key v : a) {
            this.insert(v);
        }
    }

    public void insert(Key v) {
        //把元素插入到链表的最前面，不需要关心链表是否为空
        Node oldFirst = first;
        first = new Node(v);
        first.next = oldFirst;
        size++;
    }

    public Key max() {
        if(isEmpty()) {
            return null;
        }
        //使用三个指针，max指向最大值;pre指向最大值的前一个节点
        //i进行循环和max比较
        Node max = first;
        Node pre = first;
        Node i = first;
        //当i指向最后一个元素时，循环结束
        while (i.next != null) {
            if(less(max.val, i.next.val)) {
                //当i指向的节点的下一个节点的值大于max指向节点的值时，
                // 那么pre指向i对应节点，max指向i指向的节点的下一个节点
                pre = i;
                max = i.next;
            }
            i = i.next;
        }
        //结束循环后，i一定指向最后一个节点
        //max指向最大值对应节点，pre指向max的前一个节点
        /*此时分三种情况：
            1. 最大值是第一个节点
            2. 最大值是最后一个节点
            3. 最大值是中间任意一个节点

          对于第一种情况，不需要做任何操作；对于2,3种情况，可以合并在一起解决
        */
        //将最大值挪到链表最前面
        if(max != first) {
            pre.next = max.next;
            max.next = first;
            first = max;

        }
        return first.val;
    }

    public void delMax() {
        Key v = max();
        if(v != null) {
            first = first.next;
        }
    }

    public void show() {
        Node i = first;
        while (i != null) {
            System.out.print(i.val + " ");
            i = i.next;
        }
        System.out.println();
    }

    public boolean isEmpty() {
        return first == null;
    }
    public int size() {
        return this.size;
    }

    private boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }


}

```





### 优先队列的时间复杂度

​		实现栈或者队列与实现优先队列的最大不同在于对性能的要求，对于栈和队列，我们的实现能够在常数时间完成所有操作。

因为不需要管是否有序。

​		但是对于优先队列，刚刚讨论的所有初级实现，**插入元素**和**删除最大元素**这两个操作之一在最坏情况下需要在线性时间下完成。       而且只要一个操作最坏情况在线性时间完成，另一个操作只需要常数时间。

| 数据结构 | 插入元素 | 删除最大元素 |
| :------: | :------: | :----------: |
| 有序数组 |    N     |      1       |
| 无序数组 |    1     |      N       |
|    堆    |   logN   |     logN     |
| 理想情况 |    1     |      1       |

链表的有序和无序，和数组相同。





















