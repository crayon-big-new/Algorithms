# 5-希尔排序

## 算法思想

希尔排序是基于插入排序的排序算法。 快速排序对于大规模的乱序数组性能比较差。因为插入排序只能交换相邻的元素。

希尔排序为了加快速度改进了插入排序，交换不相邻的元素，来对数组局部进行排序，并最终用插入排序将局部有序的数组排序。

希尔排序思想是：

使数组任意间隔为h的元素都是有序的，这样的数组被称为h有序数组。换句话说，一个h有序数组就是h个互相独立的有序数组编制在一块。最后h为1的h序列，就可以将数组排序。书中例子使用了序列${1/2} * ({3^k - 1})$，从N/3开始，递减到1。把这个序列成为递增序列。每一个h都用一次插入排序，最后一次，h为1，即可把整个数组排序。



**间隔为h，那么就会有h个子数组**。0~h - 1 对应的每个元素，为每个子数组的第一个元素。

## 算法实现

```java
    
    public static void sort(Comparable[] a) {
        int N = a.length, h = 1;
        while (h < N / 3) {
            h = 3 * h + 1;
        }
        while (h >= 1) {
            //i从h开始，因为0 ~ (h - 1)是各子数组的第一个元素
            for(int i = h; i < N; i++) {
                //j>=h，因为当j为子数组的第二个元素时，j - h就是子数组第一个。每次都要比较a[j]和a[j-1]
                for(int j = i; j >= h && less(a[j], a[j - h]); j = j - h) {
                    exch(a, j, j - h);
                }
            }
            h = h / 3;
        }
    }
```



h最后一定会为 1，因为h = 3 * h + 1，所以每次除3，最后一定会归为 1 。当h为 1后，进入循环，进行插入排序，整个数组排好序。





## h递增序列

算法的性能不仅取决于h，还取决于h之间的数学性质。不同的递增序列，性能不同。但还没有被证明哪一种递增序列是最好的。

这里选用了${1/2} * ({3^k - 1})$递增序列。



## 算法性能分析

上述算法实现，是唯一无法准确描述对于乱序的数组的性能特征的排序方法。

但已知，运行时间达不到平方级别。

## 插入排序和希尔排序的性能比较

同样使用SortCompare类，这里不再展示代码。

运行结果为：
<img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201031135546359.png" alt="image-20201031135546359" style="zoom:50%;" />





<img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201031142242590.png" alt="image-20201031142242590" style="zoom:50%;" />





## 特点

希尔排序要比选择排序和插入排序快得多。并且数组规模越大，优势越明显。









