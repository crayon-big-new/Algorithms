# 7-快速排序

## 算法思想

快速排序基于分治的思想，它将一个数组分成两个子数组，将两部分独立的排序。

归并排序和快速排序是互补的：归并排序是将数组分成两个子数组后排序，然后将有序子数组归并起来完成数组排序；而快速排序则是当两个子数组有序时，整个数组也就自然有序了。归并排序中，递归调用发生在处理整个数组之前；快速排序中，递归调用发生在处理整个数组之后。

归并排序中，数组被等分为两半；快速排序中，切分的位置取决于数组的内容。

快速排序的关键在于切分，这个过程使得数组满足三个条件：

- 对于某个j，a[j]已经排定，即已经在整个数组的正确位置
- a[lo]到a[j -1]的所有元素都不大于a[j]
- a[j+1]到a[hi]的所有元素都不小于a[j]



实现整个快排，首先要实现切分方法，一般策略是选定a[lo]为切分元素，即给定数组的第一个元素，以第一个元素为基准，从第二个元素开始，比第一个元素小的，在左边；大的，在右边。

实现方法：首先指针i从第二个元素开始进行向右扫描，直到找到一个大于等于a[lo]的元素；然后指针j再从最右端开始，向左扫描，直到找到一个小于等于a[lo]的元素，显然，这两个元素没有排定顺序，交换他们的位置，然后继续扫描。直到两个指针相遇，我们只需要将a[lo]和左子数组最右边元素a[j]交换，返回 j 即可。





## 算法实现

```java
    public static void sort(Comparable[] a) {
        sort(a, 0, a.length -1);
    }

    private static void sort(Comparable[] a, int lo, int hi) {
        //当数组只有一个元素，就直接返回
        if(hi <= lo) {
            return;
        }
        int j = partition(a, lo, hi);
        //j已经在正确位置，递归地排序j左边子数组和右边子数组
        sort(a, lo, j - 1);
        sort(a, j + 1, hi);

    }

    private static int partition(Comparable[] a, int lo, int hi) {
        //i从数组第一个元素开始，j表示数组长度，减一才是最后一个元素
        int i = lo, j = hi + 1;
        //以数组第一个元素为界来进行划分
        Comparable v = a[lo];
        while (true) {
            //i从第二个元素开始，如果a[i]小于v，就继续循环，
            // 当a[i]大于v，或者i == hi，即到头以后，就结束循环
            //其中i == hi,对应的是包括第二个元素以后的所有元素都小于第一个元素的情况
            while (less(a[++i], v)) {
                if (i == hi) {
                    break;
                }
            }
            //j从最后一个元素开始，如果a[j]大于v,就继续循环，
            //当a[j]小于v，或者j == lo，就是到头以后，就结束循环
            //其实，while语句中的if语句可以省略，因为最后一个比较的是v自身，他不可能比他自己小，所以一定会结束循环
            while (less(v, a[--j])) {
                if (lo == j) {
                    break;
                }
            }
                //当前两个循环都结束时，如果i < j那么就需要交换，
                // 如果i > j，证明循环结束，此时j对应的是小于v的元素，i对应的是大于v的元素
                //如果i == j，说明此时i和j指向的元素和v相等
            if (i >= j) {
                break;
            }

            exch(a, i, j);
        }
            //整个循环结束，此时需要交换第一个元素和j位的元素
            //j对应元素要么小于v，要么等于v
            exch(a, lo, j);
            return j;

        }

```





## 几个注意的事项

### 原地切分

如果使用一个辅助数组，可以很容易实现切分，但是将切分后的数组复制回去，得不偿失。

### 别越界

如果切分元素是数组中最小或者最大的那个元素，就得小心不要让扫描指针跑出数组的边界。

partition方法通过测试边界值来预防这种情况，但是，测试条件(j == lo)是多余的，因为切分元素是a[lo]，他可能比他自己小。

可以去掉。

### 保持随机性

数组元素的顺序是被打乱过的，算法对所有的子数组一视同仁，他的所有子数组也都是随机排序的。

### 终止循环

正确的检查指针是否越界，正确结束循环。一个最常见的错误是没有考虑到数组中可能包含和切分元素的值相同的其他元素。

### 处理切分元素值有重复的情况

左侧扫描最好是在遇到大于**等于**切分元素值的元素时停下，右侧扫描是在遇到小于**等于**切分元素值的元素时停下，尽管这样可能会不必要的将一些等值元素交换，但是在一些典型应用中，可以避免算法的时间编程平方级别。

### 终止递归

保证递归能够结束是需要很小心的，快排也是这样，例如，实现快排最常见的错误是 不能保证将切分元素放入正确位置，从而导致程序元素正好是子数组的最大或最小元素时陷入了无限的递归循环中。



## 算法性能分析

命题1：将长度为N的无重复数组排序，快速排序平均需要~$2N{lgN}$次比较。

快速排序有一个潜在缺点，就是在切分不平衡时，程序执行会非常低效。例如第一次从最小的元素划分，第二次从第二小的元素划分，每次只会移除一个元素，导致一个大子数组需要切分很多次。

在快速排序之前，要先将数组进行随机排序就是为了避免这种情况，它能够使产生糟糕的切分的可能性降到最低。

命题2：快速排序最多需要约 $N^2/2$次比较，但是随机打乱数组可以避免这种情况。



## 算法改进



### 切换到插入排序

和大多数递归排序算法一样，改进快速排序的一个简单方法基于下面两点：

- 对于小数组，快速排序比插入排序慢
- 因为递归，快速排序的sort方法在小数组中也会调用自己

所以在排序小数组时，应该切换到使用插入排序。

改动方法：利用插入排序原理写一个可以对数组的任意子数组进行排序的算法

```java
    //可以给数组的任意一个子数组进行排序
    public static void sort(Comparable[] a, int lo, int hi) {

        if(lo >= hi) {
            return;
        }
        for(int i = lo + 1; i <= hi; i++) {
            for(int j = i; j > lo; j--) {
                if(less(a[j], a[j -1])) {
                   exch(a, j, j - 1);
                } else {
                    break;
                }
            }
        }
    }

```



然后改动快速排序中sort方法，将 `if(hi <= lo) return;`改成`if(hi <= lo + M){InsertSort.sort(a, lo, hi); return;}`即可。

转换参数M的最佳值是和系统相关的，M决定了什么数组可以定义为小数组，一般 5~15之间的任意值在大多数情况下可以令人满意。



### 三取样切分

改进快速排序另一个方法是，使用子数组的一部分元素取中位数，用中位数来切分数组，这样性能会更好。但是代价是要计算中位数。 人们发现将取样大小为3的并用居中的元素切分的效果最好(即在子数组中任意取三个数，取他们的中位数)。



### 熵最优的排序

实际应用中经常会含有大量重复元素的数组。所以一个元素全部相同的子数组就不需要排序了，但是快速排序还是会切分为更小的数组。 在有大量重复元素的情况下，快速排序的递归性会产生大量的元素相同子数组。这就有改进的空间，将线性对数级改进为线性级别。

一个改进的方法是，把数组切分为三部分，分别是大于，等于，小于切分元素。

#### 算法实现

```java
    private static void sort(Comparable[] a, int lo, int hi) {

        if(lo >= hi) {return;}
        //三个指针，循环结束后，保证a[0~lt - 1]的元素小于v,a[lt ~ gt]的元素等于v
        //a[gt + 1 ~ hi]的元素大于v
        int lt = lo, i = lo + 1, gt = hi;
        Comparable v = a[lo];
        while (i <= gt) {
            int cmp = a[i].compareTo(v);
            if(cmp < 0) {

                exch(a, i++, lt++);
            } else if(cmp > 0) {
                //gt换过来的元素还没有和v比较过，所以这里i不加一
                exch(a, i, gt--);
            } else {
                i++;
            }
        }
        //递归，排序子数组
        sort(a, lo, lt -1);
        sort(a, gt +1, hi);

    }

```



