# 2-选择排序

## 算法思想

首先找到数组中最小的元素，然后将这个元素和数组中的第一个元素交换位置。其次，在**剩下的元素**中再找到最小的元素，和数组中第二个元素交换位置。如此往复，一直到只剩最后一个元素为止。此时，整个数组排序完成。

这种方法叫做选择排序，它在不断地进行选择剩余元素中的最小者。



## 算法实现

```java
    public static void sort(Comparable[] a) {
        //i从0到a.length - 1
        for(int i = 0; i < a.length; i++) {
            //将i对应元素设为最小值
            int min = i; 
            for(int j = i + 1; j < a.length; j++) {
                //如果a[j]小于a[i](后面的小于前面的)，就把min设为j
                if(less(a[j], a[min])) {
                    min = j;
                }
            }
            //每结束一个循环，就交换最小值和a[i]
            exch(a, i, min);
        }
    
    }
```



## 算法性能分析

在外循环，每次找到一个最小的都交换一次，所以总交换次数为N次，即数组长度。

算法时间效率取决于比较的次数：

每一个元素，都要和后面的元素进行比较，所有总的比较次数为 (N - 1) + (N - 2) + (N -3) + .... 1  = 	**$\frac{N(N-1)}{2}$**



总上，对于长度为N的数组，选择排序需要${N^2}/2$次比较和N次交换



## 特点

- 运行时间和输入无关。为了找到最小的元素扫描一遍数组不能为下一次扫描提供什么有效信息。这种性质在某些情况下是缺点。因为一个有序数组和一个无序数组所用排序时间一样长。
- 数据移动(交换)是最少的。选择排序交换次数和数组长度是线性关系。其他任何算法不具有这个特征(大部分是线性对数或平方关系)











